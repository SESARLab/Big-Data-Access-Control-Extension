\section{Maximizing the Pipeline Instance Quality}\label{sec:heuristics}
    
  %
  % %Ovviamente non è sufficiente scegliere il best service per ogni vertice, ma diventa un problema complesso dove si devono calcolare/valutare tutte le possibili combinazioni dei servizi disponibili, tra le quali scegliere la migliore.    
The goal of this paper is to produce a pipeline instance with maximum quality, i.e., guaranteeing a high level of data protection but at the same time the minimum amount of information lost across the pipeline. To this aim, we first discuss the crucial role of well-defined metrics (\cref{sec:metrics}) to specify and measure data quality, and describe the ones that will be used in the paper. 
Then, we prove that the problem of maximizing the pipeline instance quality is NP-hard (\cref{sec:nphard}). Finally, we present a parametric heuristic (\cref{subsec:heuristics}) tailored to address the computational complexities associated with enumerating all possible combinations within a given set. The primary aim of the heuristic is to approximate the optimal path for service interactions and transformations, particularly within the landscape of more complex pipelines composed numerous nodes and candidate services.
Our focus extends beyond identifying optimal combinations, encompassing an understanding of the quality changes introduced during the transformation processes.

%Inspired by existing literature, these metrics, categorized as quantitative and statistical, play a pivotal role in quantifying the impact of policy-driven transformations on the original dataset.

\subsection{Quality Metrics}\label{sec:metrics}
Ensuring data quality is mandatory to implement data pipelines that provide high-quality results and decision-making along the whole pipeline execution. To this aim, we define a set of metrics evaluating the quality loss introduced by our policy-driven transformation in Section~\cite{ADD} on the input dataset \origdataset at each step of the data pipeline. Our metrics can be classified as \emph{quantitative} and \emph{statistical}~\cite{ADD}, and compare the input dataset \origdataset\ and dataset \transdataset\ generated by enforcing data protection requirements on \origdataset. 

Quantitative metrics monitor the amount of data lost during data transformations as the difference in quality between datasets \origdataset\ and \transdataset.
Statistical metrics take into consideration the changes in the statistical properties of datasets \origdataset\ and \transdataset. We note that these metrics can be applied either to the entire dataset or to specific features only. The features can be assigned with equal or varying importance, enabling the prioritization of important features that might be possibly lost during the policy-driven transformation in Section~\cite{ADD}.

\subsubsection{Jaccard coefficient}
The Jaccard coefficient can be used to measure the difference between the elements in two datasets.
It is defined as:\[J(X,Y) = \frac{|X \cap Y|}{|X \cup Y|}\]
where X and Y are two datasets of the same size.

The Jaccard coefficient is computed by dividing the cardinality of the intersection of two sets by the cardinality of their union. It ranges from 0 to 1, where 0 indicates no similarity and 1 indicates complete similarity between the datasets.

The Jaccard coefficient has several advantages. Unlike other similarity measures, such as Euclidean distance, it is not affected by the magnitude of the values in the dataset. It is suitable for datasets with categorical variables or nominal data, where the values do not have a meaningful numerical interpretation.

\subsubsection{Weighted Jaccard coefficient}
The Jaccard coefficient can be extended with weights modeling the importance of each element in the dataset.
The Weighted Jaccard coefficient is defined as:\[J(X,Y) = \frac{\sum_{i=1}^{n}w_i(x_i \cap y_i)}{\sum_{i=1}^{n}w_i(x_i \cup y_i)}\]
where X and Y are two datasets of the same size.

It is computed by dividing the cardinality of the intersection of two datasets by the cardinality of their union, weighted by the importance of each element in the datasets. Weights prioritize certain elements (e.g., a specific feature) in the datasets.
The Weighted Jaccard coefficent can then account for element importance and provide a more accurate measure of similarity.

\subsubsection{Jensen-Shannon Divergence}
The Jensen-Shannon divergence (JSD) is a symmetrized version of the KL divergence~\cite{ADD} and can be used to measure the dissimilarity between the probability distributions of two datasets.

The JSD between X and Y  is defined as:

\[JSD(X, Y) = \frac{1}{2} \left( KL(X || M)
  + KL(Y || M) \right)\]

where X and Y are two datasets of the same size, and M$=$0.5*(X+Y) is the average distribution.

JSD incorporates both the KL divergence from X to M and from Y to M. It provides a balanced measure of dissimilarity that is symmetric and accounts for the contribution from both datasets.
%
JSD can compare the dissimilarity of the two datasets, providing a symmetric and normalized measure that considers the overall data distribution.
%
It provides a more comprehensive understanding of the dissimilarity between X and Y, taking into account the characteristics of both datasets.

\subsubsection{Weighted Jensen-Shannon Divergence}
JSD can be extended to incorporate weights in the calculation, resulting in a weighted version of the dataset divergence. The Weighted Jensen-Shannon Divergence (WJSD) accounts for the importance or relevance of specific elements in the datasets being compared.

The WJSD between X and Y is defined as:
\begin{align*}
  WJSD(X, Y) = \frac{1}{2} \left( \sum_{i=1}^{n} w_i \left( x_i \log \frac{x_i}{m_i} \right) \right. \\
  \left. + \sum_{i=1}^{n} w_i \left( y_i \log \frac{y_i}{m_i} \right) \right)
\end{align*}

where X and Y are two datasets of the same size, x\_i$\in$X and y\_i$\in$Y are the elements of X and Y, respectively, w\_i represents the weights assigned to each element, and \[m_i = \frac{{x_i + y_i}}{2}\] is the average of the corresponding elements.

By incorporating weights into the JSD calculation, WJSD provides a more accurate measure of dissimilarity between X and Y, considering the importance of individual elements based on the assigned weights. This approach is particularly useful when elements in the datasets have varying levels of significance, enabling a more tailored analysis of dissimilarity.

\subsection{NP-Hardness of the Max Quality Pipeline Instantiation Process}\label{sec:nphard}

 \begin{definition}[Max Quality Pipeline Instantiation Process]\label{def:MaXQualityInstance}
Given \textit{dtloss}$_i$ the value of the quality metrics computed after applying the transformation of the policy matching the service selected to instantiate vertex  \vi{i}$\in$$\V_S$, the Max quality \problem is the case in which the \emph{pipeline instantiation} function returns a \pipelineInstance where the \textit{dtloss}$_i$ sum is maximized.
\end{definition}
 
The Max Quality \problem is a combinatorial selection problem and is NP-hard, as stated by the following theorem.
However, while the overall problem is NP-hard, there is a component of the problem that is solvable in polynomial time: matching the profile of each service with the node policy. This can be done by iterating over each node and each service, checking if the service matches the node’s policy. This process would take $O(|N|*|S|)$ time. This is polynomial time complexity.

\begin{theorem}
  The Max Quality  \problem is NP-Hard.
\end{theorem}
\emph{Proof: } 
The proof is a reduction from the multiple-choice knapsack problem (MCKP), a classified NP-hard combinatorial optimization problem, which is a generalization of the simple knapsack problem (KP) \cite{}. In the MCKP problem, there are $t$ mutually disjoint classes $N_1,N_2,…N_t$ of items to pack in some knapsack of capacity $C$, class $N_i$ having size $n_i$. Each item $j \in N_i$ has a profit $p_{ij}$ and a weight $w_{ij}$; the problem is to choose one item from each class such that the profit sum is maximized without having the weight sum to exceed C. 

The MCKP can be reduced to the Max quality \problem in plynomial time, with $N_1,N_2,…N_t$ corresponding to $S^c_{1}, S^c_{1}, ..., S^c_{u},$, $t=u$ and $n_i$ the size of $S^c_{i}$. The profit $p_{ij}$ of item $j \in N_i$ corresponds to \textit{dtloss}$_{ij}$ computed for each candidate service $s_j \in S^c_{i}$, while $w_{ij}$ is uniformly 1 (thus, C is always equal to the cardinality of $V_C$).

Since the reduction can be done in polynomial time, our problem is also NP-hard. (non è sufficiente, bisogna provare che la soluzione di uno e' anche soluzione dell'altro)


\begin{example}[Max-Quality Pipeline Instance]
\end{example}

% The metrics established will enable the quantification of data loss pre- and post-transformations.
% In the event of multiple service interactions, each with its respective transformation,
% efforts will be made to minimize the loss of information while upholding privacy and security standards.
% Due to the exponential increase in complexity as the number of services and transformations grow,
% identifying the optimal path is inherently an NP-hard problem.
% As such, we propose some heuristics to approximate the optimal path as closely as possible.
%To evaluate their efficacy, the heuristically generated paths will be compared against the optimal solution.

\subsection{Heuristic}\label{subsec:heuristics}
%The computational challenge posed by the enumeration of all possible combinations within a given set is a well-established NP-hard problem.}
%The exhaustive exploration of such combinations swiftly becomes impractical in terms of computational time and resources, particularly when dealing with the analysis of complex pipelines.
%In response to this computational complexity, the incorporation of heuristic emerges as a strategy to try to efficiently address the problem.
\hl{HO RIVISTO IL PARAGRAFO VELOCEMENTE GIUSTO PER DARE UN'INDICAZIONE. DOBBIAMO USARE LA FORMALIZZAZIONE E MAGARI FORMALIZZARE ANCHE LO PSEUDOCODICE.} We design and implement a heuristic algorithm for computing the pipeline instance maximizing data quality. Our heuristic is built on a \emph{sliding window} and aims to minimize information loss according to quality metrics. At each step, a set of nodes in the pipeline template $\tChartFunction$ is selected according to a specific window w=[i,j], where $i$ and $j$ are the starting and ending depth of window w. Service filtering and selection in Section~\ref{sec:instance} are then executed to minimize information loss in window w. The heuristic returns as output the list of services instantiating nodes at depth $i$. A new window w=[i+1,j+1] is considered until $j$+1 is equal to the max depth of $\tChartFunction$, that is the window reaches the end of the template. 
%For example, in our service selection problem where the quantity of information lost needs to be minimized, the sliding window algorithm can be used to select services composition that have the lowest information loss within a fixed-size window. 
This strategy ensures that only services with low information loss are selected at each step, minimizing the overall information loss. Pseudo-code for the sliding window algorithm is presented in Algorithm 1.

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{commentsColor}\textit,    % comment style
  deletekeywords={list},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=tb,	                   	   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{keywordsColor}\bfseries,       % keyword style
  language=Python,                 % the language of the code (can be overrided per snippet)
  otherkeywords={*,to,function, Seq, add,empty},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{commentsColor}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{stringColor}, % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  columns=fixed                    % Using fixed column width (for e.g. nice alignment)
}

\begin{lstlisting}[frame=single, caption={Sliding Window Heuristic} ,label={lst:slidingwindow}]
function SlidingWindowHeuristic(Seq sequence, int windowSize):

  selectedNodes = empty
  for i from 0 to length(sequence) - windowSize:
    minMetricNode = None
    minMetricValue = infinity
    for j from i to i + windowSize:
      currentMetric = calculateMetric(sequence[j])
      if currentMetric < minMetricValue:
        minMetricValue = currentMetric
        minMetricNode = sequence[j]
    add minMetricNode to selectedNodes
  return selectedNodes
\end{lstlisting}
The pseudocode implemets function {\em SlidingWindowHeuristic}, which takes a sequence of nodes and a window size as input and returns a set of selected nodes as output. The function starts by initializing an empty set of selected nodes (line 3). Then, for each node in the sequence (lines 4--12), the algorithm iterates over the nodes in the window (lines 7--11) and selects the node with the lowest metric value (lines 9-11). The selected node is then added to the set of selected nodes (line 12). Finally, the set of selected nodes is returned as output (line 13).

We note that a window of size 1 corresponds to the \emph{greedy} approach, while a window of size N, where N represents the total number of nodes, corresponds to the \emph{exhaustive} method.

The utilization of heuristic in service selection can be enhanced through the incorporation of techniques derived from other algorithms, such as Ant Colony Optimization or Tabu Search.
By integrating these approaches, it becomes feasible to achieve a more effective and efficient selection of services, with a specific focus on eliminating paths that have previously been deemed unfavorable.

%\AG{It is imperative to bear in mind that the merging operations subsequent to the selection process and the joining operations subsequent to the branching process are executed with distinct objectives. In the former case, the primary aim is to optimize quality, whereas in the latter, the foremost objective is to minimize it.}
