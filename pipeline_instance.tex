\section{Pipeline Instance}\label{sec:instance}
%Given a set of candidate services, a
A \pipelineInstance $\iChartFunction$ instantiates a \pipelineTemplate \tChartFunction by selecting and composing services according to data protection and functional annotations in the template. It is formally defined as follows.
\vspace{0.5em}
\begin{definition}[Pipeline Instance]\label{def:instance}
  Let \tChartFunction be a pipeline template, a pipeline Instance $\iChartFunction$ is an isomorphic directed acyclic graph where:
  \begin{enumerate*}[label=\textit{\roman*})]
    \item $v'_r$$=$$v_r$;
    \item for each vertex $\vi{f}$ modeling a parallel structure, there exists a corresponding vertex $\vii{f}$;
    \item for each $\vi{i}$$\in$$\V_S$ annotated with policy \P{i} (label \myLambda(\vi{i})) and functional description $F_i$ (label \myGamma(\vi{i})), there exists a corresponding vertex \vii{i}$\in$$\Vp_S$ instantiated with a service \sii{i}, such that:
  \end{enumerate*}
  \begin{enumerate}[label=\arabic*)]
    \item $s'_i$ satisfies data protection annotation \myLambda(\vi{i}) in \tChartFunction;
    \item $s'_i$ satisfies functional annotation \myGamma(\vi{i}) in \tChartFunction.
  \end{enumerate}
\end{definition}
\vspace{0.5em}
Condition 1 requires that each selected service \sii{i} satisfies the policy requirements \P{i} of the corresponding vertex \vi{i} in the \pipelineTemplate, whereas Condition 2 is needed to preserve the process functionality, as it simply states that each service \sii{i} must satisfy the functional requirements \F{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.

We then define a \emph{pipeline instantiation} function that takes as input a \pipelineTemplate \tChartFunction and a set $S^c$ of candidate services, split in a specific set of services $S^c_{i}$ for each vertex \vi{i}$\in$$\V_S$, and returns as output a \pipelineInstance \iChartFunction. Recall from Section~\ref{sec:funcannotation} that all candidate services meet the functional annotation in the template, meaning that Condition 2 in Definition~\ref{def:instance} is satisfied for all candidate services.

The \pipelineInstance  is generated by traversing the \pipelineTemplate with a breadth-first search algorithm, starting from the root vertex \vi{r}.
Then, for each vertex $\vi{f}$ in the pipeline template, the corresponding vertex $\vii{f}$ is generated.
Finally, for each vertex \vi{i}$\in$$\V_S$, a two-step approach is applied as follows.

\begin{enumerate}
  \item \textit{Filtering Algorithm} -- It checks whether profile \profile$_j$ of each candidate service $\si{j}$$\in$$S^c_{i}$ satisfies at least one policy in \P{i}. If yes, service $\si{j}$ is compatible, otherwise it is discarded. The filtering algorithm finally returns a subset $S'_{i}$$\subseteq$$S^c_{i}$ of compatible services for each vertex \vi{i}$\in$$\V_S$.
  \item \textit{Selection Algorithm} -- The selection algorithm selects one service $s'_i$ for each set $S'_{i}$ of compatible services, which instantiates the corresponding vertex $\vii{i}$$\in$$\Vp$. There are many ways of choosing $s'_i$, we present our approach based on the maximization of data \quality \emph{\q} in Section \ref{sec:heuristics}.
\end{enumerate}

When all vertices $\vi{i}$$\in$$V$ in $G^{\myLambda,\myGamma}$ have been visited, the \pipelineInstance G' is generated, with a service instance $s'_i$ for each \vii{i}$\in$\Vp. Vertex \vii{i} is still annotated with policies in \P{i} according to \myLambda, because policies in \P{i} are evaluated and enforced only when the pipeline instance is triggered before any service is executed. In the case of policy evaluation returns \emph{true}, data transformation \TP$\in$\P{i} is applied, otherwise a default transformation that removes all data is applied.

\begin{figure}[ht!]
  \centering
  \newcommand{\function}[1]{$\instanceChartAnnotation{}_{#1}$}
  \begin{tikzpicture}[scale=0.7]
    % vertexes
    \node[draw, circle, fill,text=white,minimum size=1 ] (sr) at (0,0) {};

    % \node[draw, circle] (node2) at (1,0) {$\s{1}$};
    \node[draw, circle, plus,minimum size=1.5em] (plus) at (1.5,0) {};

    \node[draw, circle] (s2) at (3.5,-2) {$\sii{1}$};
    \node[draw, circle] (s3) at (3.5,0) {$\sii{2}$};
    \node[draw, circle] (s1) at (3.5,2) {$\sii{3}$};

    \node[draw, circle] (s4) at (5,0) {$\sii{4}$};
    \node[draw, circle] (s5) at (6.5,0) {$\sii{5}$};

    \node[draw, circle] (s6) at (8.0,0) {$\sii{6}$};
    \node[draw, circle] (s7) at (9.5,0) {$\sii{7}$};
    % Text on top
    \node[above] at (sr.north)  {$\vi{r}$};
    \node[above] at (s1.north)  {\function{3}};

    \node[above] at (s2.north)  {\function{1}};
    \node[above] at (s3.north)  {\function{2}};
    \node[above] at (s4.north)  {\function{4}};
    \node[above] at (s5.north)  {\function{5}};
    % \node[above] at (s6.north)  {\function{}};
    \node[above] at (s6.north)  {\function{6}};
    \node[above] at (s7.north)  {\function{7}};
    % Connection

    % \draw[->] (node2) -- (node3);
    \draw[->] (sr) -- (plus);
    \draw[->] (plus) -- (s1);
    \draw[->] (plus) -- (s2);
    \draw[->] (plus) -- (s3);

    \draw[->] (s1) -- (s4);
    \draw[->] (s2) -- (s4);
    \draw[->] (s3) -- (s4);
    % \draw[->] (node6) -- (node65);
    % \draw[->] (node65) -- (node7);3
    \draw[->] (s4) -- (s5);
    \draw[->] (s5) -- (s6);
    % \draw[->] (cross) -- (s5);
    % \draw[->] (cross) -- (s6);
    % \draw[->] (s5) -- (s7);
    % \draw[->] (s6) -- (s7);
    \draw[->] (s6) -- (s7);

  \end{tikzpicture}
  \caption{Service composition instance}
  \label{fig:service_composition_instance}
\end{figure}