\section{Pipeline Instance}\label{sec:instance}
A \pipelineInstance $\iChartFunction$ instantiates a \pipelineTemplate \tChartFunction by selecting and composing services according to data protection and functional annotations in the template. It is formally defined as follows.
\vspace{0.5em}
\begin{definition}[Pipeline Instance]\label{def:instance}
  Let \tChartFunction be a pipeline template, a Pipeline Instance $\iChartFunction$ is an isomorphic directed acyclic graph where:
  \begin{enumerate*}[label=\textit{\roman*})]
    \item $v'_r$$=$$v_r$;
    \item for each vertex $\vi{f}$ modeling a parallel structure, there exists a corresponding vertex $\vii{f}$;
    \item for each $\vi{i}$$\in$$\V_S$ annotated with policy \P{i} (label \myLambda(\vi{i})) and functional description $F_i$ (label \myGamma(\vi{i})), there exists a corresponding vertex \vii{i}$\in$$\Vp_S$ instantiated with a service \sii{i}, such that:
  \end{enumerate*}
  \begin{enumerate}[label=\arabic*)]
    \item $s'_i$ satisfies data protection annotation \myLambda(\vi{i}) in \tChartFunction;
    \item $s'_i$ satisfies functional annotation \myGamma(\vi{i}) in \tChartFunction.
  \end{enumerate}
\end{definition}

\vspace{0.5em}

Condition 1 requires that each selected service \sii{i} satisfies the policy requirements \P{i} of the corresponding vertex \vi{i} in the \pipelineTemplate, whereas Condition 2 is needed to preserve the process functionality, as it simply states that each service \sii{i} must satisfy the functional requirements \F{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.

We then define a \emph{pipeline instantiation} function that takes as input a \pipelineTemplate \tChartFunction and a set $S^c$ of candidate services, and returns as output a \pipelineInstance \iChartFunction. We note that $S^c$ is partitioned in different sets of services $S^c_{i}$, one for each vertex \vi{i}$\in$$\V_S$. Recall from Section~\ref{sec:funcannotation} that all candidate services meet the functional annotation in the template, meaning that Condition 2 in Definition~\ref{def:instance} is satisfied for all candidate services.

{\color{OurColor}The pseudocode of the pipeline instantiation process is presented in \cref{fig:instantiate-pseudocode}.} The \pipelineInstance  is generated by traversing the \pipelineTemplate with a breadth-first search algorithm {\color{OurColor}(line 4-10)}, starting from the root vertex \vi{r}.
Then, for each vertex $\vi{f}$ in the pipeline template, the corresponding vertex $\vii{f}$ is generated {\color{OurColor}(line 5)}.
Finally, for each vertex \vi{i}$\in$$\V_S$, a two-step approach is executed as follows.

\newenvironment{redtext}{\footnotesize	\color{gray}}{~~}
\newenvironment{ourcolor}{\color{OurColor}}{~~}
\begin{figure}[!t]

  \hrule\vspace{3pt}
  \begin{ourcolor}
  \begin{tabbing}
      \INPUT\\
      $G^{\myLambda,\myGamma}$: Pipeline Template\\
      $S^c$: Candidate Services\\
      ~\\[1pt]
      \OUTPUT\\
      $G'$: Pipeline Instance\\
      ~\\[1pt]
      \funcname{Instantiate\_Pipeline($G^{\myLambda,\myGamma}$, $S^c$)}\\
      \\
      \begin{redtext}1\end{redtext}\commentall{Initialize the pipeline instance}\\
      \begin{redtext}2\end{redtext}$G'$ = $\{\}$;\\
      \begin{redtext}3\end{redtext}\commentall{Traverse the pipeline template using BFS}\\
      \begin{redtext}4\end{redtext}\com{for} \= each $v$ in $G^{\myLambda,\myGamma}$\\
      \begin{redtext}5\end{redtext}\tabone \vii{} = \funcname{Generate\_Vertex($v$)};\\
      \begin{redtext}6\end{redtext}\tabone $G'$ = $G'$ $\cup$ \vii;\\

      \begin{redtext}7\end{redtext}\tabone $S'$ = \funcname{Filter\_Services($S^c[v]$, $v$.policies)};\\
      \begin{redtext}8\end{redtext}\tabone selectedService = \funcname{Select\_A\_Service($S'$)};\\
      \begin{redtext}9\end{redtext}\tabone \vii{}.service = selectedService;\\

      \begin{redtext}10\end{redtext}\com{endfor};\\
      \begin{redtext}11\end{redtext}\com{return} $G'$;\\
      \\
      \\
      \begin{redtext}12\end{redtext}\funcname{Filter\_Services($S^c[v]$, policies)}\\
      \begin{redtext}13\end{redtext}\commentall{Filter candidate services based on policies}\\
      \begin{redtext}14\end{redtext}$S'$ = $\{\}$;\\
      \begin{redtext}15\end{redtext}\com{for} \= each service $s$ in $S^c[v]$:\\
      \begin{redtext}16\end{redtext}\tabone \com{if} \= $s$.profile satisfies any policy:\\
      \begin{redtext}17\end{redtext}\tabtwo $S'$ = $S'$ $\cup$ $s$;\\
      \begin{redtext}18\end{redtext}\tabone\com{endif};\\
      \begin{redtext}18\end{redtext}\com{endfor};\\
      \begin{redtext}19\end{redtext}\com{return} $S'$;\\

    \end{tabbing}

  \end{ourcolor}
  \hrule
  \vspace{10pt}
  \caption{\label{fig:instantiate-pseudocode} Pseudocode of the pipeline instantiation process.}
\end{figure}

\begin{enumerate}
  \item \textit{Filtering Algorithm} -- It checks whether profile \profile$_j$ of each candidate service $\si{j}$$\in$$S^c_{i}$ satisfies at least one policy in \P{i} {\color{OurColor}(line 16)}. If yes, service $\si{j}$ is compatible, otherwise it is discarded {\color{OurColor}(line 17)}. The filtering algorithm finally returns a subset $S'_{i}$$\subseteq$$S^c_{i}$ of compatible services for each vertex \vi{i}$\in$$\V_S$ {\color{OurColor}(line 19)}.
  \item \textit{Selection Algorithm} -- The selection algorithm selects one service $s'_i$ for each set $S'_{i}$ of compatible services, which instantiates the corresponding vertex $\vii{i}$$\in$$\Vp$ {\color{OurColor}(line 8-9)}. There are many ways of choosing $s'_i$, Section \ref{sec:heuristics} presents our approach based on the maximization of data \quality \emph{\q}.
\end{enumerate}

When all vertices $\vi{i}$$\in$$V$ in $G^{\myLambda,\myGamma}$ have been visited, the \pipelineInstance $G'$ is generated {\color{OurColor}(line 11)}, with a service instance $s'_i$ for each \vii{i}$\in$\Vp. Vertex \vii{i} is annotated with policies in \P{i} according to \myLambda, because policies in \P{i} are evaluated and enforced at runtime, only when the pipeline instance is triggered and before any service is executed. When policy evaluation returns \emph{true}, data transformation \TP$\in$\P{i} is applied, otherwise a default transformation that removes all data is applied.