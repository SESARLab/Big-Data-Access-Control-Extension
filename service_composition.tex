\section{Pipeline Template}
Given the pipeline definition in \cref{def:pipeline}, we use annotations to specify requirements for data protection and data transformation.
The objective of this extension is to integrate data protection and data management into the pipeline using annotations.
Annotations enable tracking of the data lifecycle by monitoring changes arising from both data manipulation and enforcement of data protection measures.

The section is structured as follows: In section 4.1, the template will be defined.
Section 4.2 provides a brief explanation of the chosen policy model, and finally, in 4.3, the data transformation will be examined and an example of a pipeline template will be provided.


\subsection{Template Definition}
The template is a pipeline annotated.
Each node is labeled two mapping functions, which will allow it to be linked to policies and the data transformation function, respectively.
The policies will be intended to guide the enforcement of data protection while the data transformation function will characterize the functional aspect of each node.
Must be noted that the template is a specification of the pipeline, and it is intended to be instantiated.
At this stage, the template is not yet linked to any service, and it is not possible to determine the actual data transformation function.

The service template is defined as follows and is depicted in \cref{fig:service_composition_template}.

\begin{definition}[Service Template] \label{def:pipeline}
  Given a pipeline G(\V,\E), a Service Template  $G^{\myLambda,\myGamma}$(V,E,\myLambda,\myGamma) is a direct acyclic graph with two labeling functions:
  \begin{enumerate*}[label=\roman*)]
    \item \myLambda is an annotation function, assigning to each vertex \vi{i}$\in$\V\ a policy $p_i\in\Pset{}$.
    \item \myGamma is an annotation function, assigning to each vertex \vi{i}$\in$\V\ a transformation function \F.
  \end{enumerate*}
\end{definition}
\begin{figure}[ht!]
  \centering
  \begin{tikzpicture}[scale=0.9]
    % Nodes
    \node[draw, circle] (node1) at (0,0) {$\s{r}$};
    \node[draw, circle] (node2) at (1,0) {$\s{1}$};
    \node[draw, circle] (node3) at (2,0) {$\timesOperator$};
    \node[draw, circle] (node4) at (3,-1) {$\s{2}$};
    \node[draw, circle] (node5) at (3,1) {$\s{3}$};
    \node[draw, circle] (node6) at (4,0) {$\timesOperator$};
    \node[draw, circle] (node65) at (5,0) {$\s{4}$};
    \node[draw, circle] (node7) at (6,0) {$\plusOperator$};
    \node[draw, circle] (node8) at (7,1) {$\s{5}$};
    \node[draw, circle] (node9) at (7,-1) {$\s{6}$};
    \node[draw, circle] (node10) at (8,0) {$\plusOperator$};
    \node[draw, circle] (node11) at (9,0) {$\s{7}$};
    % Text on top
    \node[above] at (node1.north)  {$\tChartFunction$};
    \node[above] at (node2.north)  {$\tChartFunction$};
    \node[above] at (node3.north)  {                 };
    \node[above] at (node4.north)  {$\tChartFunction$};
    \node[above] at (node5.north)  {$\tChartFunction$};
    \node[above] at (node65.north) {$\tChartFunction$};
    \node[above] at (node8.north)  {$\tChartFunction$};
    \node[above] at (node9.north)  {$\tChartFunction$};
    \node[above] at (node11.north) {$\tChartFunction$};
    % Connection
    \draw[->] (node1) -- (node2);
    \draw[->] (node2) -- (node3);
    \draw[->] (node3) -- (node4);
    \draw[->] (node3) -- (node5);
    \draw[->] (node5) -- (node6);
    \draw[->] (node4) -- (node6);
    \draw[->] (node6) -- (node65);
    \draw[->] (node65) -- (node7);
    \draw[->] (node7) -- (node8);
    \draw[->] (node7) -- (node9);
    \draw[->] (node8) -- (node10);
    \draw[->] (node9) -- (node10);
    \draw[->] (node10) -- (node11);
  \end{tikzpicture}
  \caption{Pipeline Template}
  \label{fig:service_composition_template}
\end{figure}

\begin{figure}[ht!]
  \centering
  \begin{tikzpicture}
    % Nodes
    \node[draw, circle,minimum size=1cm] (node1) at (0,0) {$\s{1}$};
    \node[draw, circle,minimum size=1cm] (node2) at (2,0) {$\s{2}$};
    \node[draw, circle,minimum size=1cm] (node3) at (4,0) {$\s{3}$};

    \node[above] at (node1.north)  {$\tChartFunction$};
    \node[above] at (node2.north)  {$\tChartFunction$};
    \node[above] at (node3.north)  {$\tChartFunction$};

    % Connection
    \draw[->] (node1) -- (node2);
    \draw[->] (node2) -- (node3);

  \end{tikzpicture}
  \caption{Pipeline Template Example}
  \label{fig:temp}
\end{figure}
\subsection{Policy}
% \subsubsection{Annotations}
% \subsubsection{Transformation}
%We consider XACML~\cite{XACML}, an attribute-based access control model that offers flexible fine-grained authorization capabilities, as the language for policy definition. XACML obligations are used to define preemptive data transformations for data protection.
We consider an attribute-based access control model that offers flexible fine-grained authorization capabilities, as the language for policy definition.
In a collaborative scenario involving large
data sets, it is more effective to perform preemptive data transformations than to deny access to data \cref{TOADD, cambiare la frase?}.
than to restrict data access altogether.
Therefore, when a user submits a resource access request, our access
control filters the returned data based on the user's privileges.
This approach ensures data protection by removing or obfuscating sensitive attributes instead of granting or denying access to the full data set.

We adapt the standard key components of an attribute-based access control model to address the unique characteristics of a big data environment.
The access control policy outlines access requirements using key components and their corresponding attributes in the following manner.

\begin{definition}[Policy Condition]\label{def:policy_cond}
  A \emph{Policy Condition} is a Boolean expression of the form $($\emph{attr\_name} op \emph{attr\_value}$)$, with op$\in$\{$<$,$>$,$=$,$\neq$,$\leq$,$\geq$\}, \emph{attr\_name} an attribute label, and \emph{attr\_value} the corresponding attribute value.
\end{definition}

A policy is then defined as follows.

\begin{definition}[Policy]\label{def:policy_rule}
  A {\it policy P} is 5-uple $<$\textit{subj}, \textit{obj}, \textit{action}, \textit{env}, \textit{\TF}$>$, where:
  \begin{description}
    \item Subject \textit{subj} defines a user or the service provider of a job issuing access requests to perform operations on objects.
          It is of the form $<$\emph{id}, \emph{PC}$>$, where \emph{id} defines a class of users (e.g., policeman), and \emph{PC} is a set of \emph{Policy Conditions} on the subject, as defined in Definition \ref{def:policy_cond}.
          For instance, $<$\emph{user},\{(role $=$ "jailer")\}$>$ refers to a person with the role of jailer.

    \item Object \textit{obj} defines any data whose access is governed by the policy.
          It is of the form $<$\emph{type}, \emph{PC}$>$, where: \emph{type} defines the type of object, such as a file (e.g., a video, text file, image, etc.), a SQL or noSQL database, a table, a column, a row, or a cell of a table, and \emph{PC} is a set of \emph{Policy Conditions} defined on the object's attributes.
          For instance, $<$\emph{dataset},\{(region $=$ CT)\}$>$ refers to a dataset whose region is CT.

    \item Action \textit{action} defines any operations that can be performed within a big data environment, from traditional atomic operations on databases (e.g, CRUD operations varying depending on the data model) to coarser operations, such as an Apache Spark Direct Acyclic Graph (DAG), an Hadoop MapReduce, an analytics function call, or an analytics pipeline.

    \item Environment \textit{env} defines a set of conditions on contextual attributes, such as time of the day, location, IP address, risk level, weather condition, holiday/workday, emergency. It is a set \emph{PC} of
          \emph{Policy Conditions} as defined in Definition \ref{def:policy_cond}.
          For instance, $<$\emph{env},\{(time $=$ "night")\}$>$ refers to a policy that is applicable only at night.

    \item Data Transformation \textit{\TF} defines a set of security and privacy-aware transformations on \textit{obj}, focusing on compliance to regulations and standards, in addition to simple format conversions.
  \end{description}
\end{definition}

Policies are activated upon a service's request for data access. Subsequently, an evaluation and transformation of said policy follows in order to deliver the resultant execution to the service. The core function of policy execution is to safeguard the data through operations, such as obfuscation of partial or complete records, or filter row implementation. It's essential to note that policies always permit data access. However, in cases where the user lacks the authorization to read the data, an empty set is returned.

% \subsubsection{Policy Decision/Policy Matching}
% Policy decision is the process of determining whether a given access request is allowed or denied. It is based on the evaluation of a set of policies, which are matched against the access request. The matching process is based on the following elements.


% \subsubsection{Policy Enforcement}
% \subsubsection{Policy Evaluation}
\subsection{Data Transformation}
We also note that each service $s_i$ in \vi{i}$\in$\V\ receives a set of data as input, processes them according to data transformation \F\ annotated on , and possibly produces a result as output.
In a big data service composition pipeline, the transformation function is a crucial component of each service.
It processes, modifies, or transforms the data received by the service as part of the pipeline.
These functions are applied to the data as it progresses through various stages of the pipeline, enabling each service to perform its designated tasks or operations on the data.
The transformation function can belong to one of four main types.
\begin{enumerate*}[label=\roman*)]
  \item Function \F{e}, an empty function that applies no transformation or processing on the data.
  \item Function \F{a}, an additive function expands the amount of data received, for example, by integrating data from other sources.
  \item Function \F{t}, a transformation function that transforms some records in the dataset without altering the domain.
  \item Function \F{d}, a transformation function that changes the domain of the data by applying, for instance, PCA or K-means (out of the scope of this work).
\end{enumerate*}


\begin{example}[Pipeline Template]\label{ex:pipeline}

  As an example, let us consider a pipeline template G(\V,\E,\myLambda,\myGamma) with three nodes, as depicted in \cref{fig:service_composition_example}.
  It includes three key stages: data anonymization, data enrichment, and data aggregation, each with its respective policy and transformation functions.
  The actual pipeline in the reference scenario would likely have more nodes and complexity, but this example captures the essence of the data processing steps.

  \begin{enumerate*}[label=n\arabic*)]
    \item The first node in our example is responsible for anonymizing the data.
          It specify the requirement of an anonymization policy ($\myLambda(v_1)$) to protect sensitive information, such as personally identifiable information (PII) in the dataset.
          The transformation function ($\myGamma(v_1)$) is required as an empty function, as no transformation is required for anonymization.
    \item The second node focuses on data enrichment, where additional information from the states of New York and New Hampshire is integrated into the dataset.
          It requires a data enrichment policy ($\myLambda(v_2)$) to ensure that the added data is relevant and compliant with privacy regulations.
          The transformation function (($\myGamma(v_2$) needed for this node is an additive function ($F_a$), which merges and integrates the external data with the existing dataset.
    \item The third node is responsible for aggregating data, including statistical measures like averages, medians, and some more statistics.
          It follows an aggregation policy ($\myLambda(v_3)$) to define how the aggregation should be performed and ensure compliance with privacy and security regulations.
          The transformation function (($\myGamma(v_3)$) for this node is a transformation function ($F_t$), which computes the required statistics and aggregates the data.
  \end{enumerate*}



  %A service pipeline is as a direct acyclic graph G(\V,\E), where \V\ is a set of vertices, one for each service $s_i$ in the pipeline, \E\ is a set of edges connecting two services $s_i$ and $s_j$, and \myLambda\ is an annotation function that assigns a label \myLambda(\vi{i}), corresponding to a data transformation \F\ implemented by the service $s_i$, for each vertex \vi{i}$\in$\V.
\end{example}

\section{Service Instance}

\begin{figure}[ht!]
  \centering
  \begin{tikzpicture}[scale=0.85]
    \node[draw, circle] (node1) at (0,0) {$s^\prime_r$};
    \node[draw, circle] (node2) at (1,0) {$s^\prime_1$};
    \node[draw, circle] (node3) at (2,0) {$\timesOperator$};
    \node[draw, circle] (node4) at (3,-1) {$s^\prime_2$};
    \node[draw, circle] (node5) at (3,1) {$s^\prime_3$};
    \node[draw, circle] (node6) at (4,0) {$\timesOperator$};
    \node[draw, circle] (node65) at (5,0) {$s^\prime_4$};
    \node[draw, circle] (node7) at (6,0) {$\plusOperator$};
    \node[draw, circle] (node8) at (7,1) {$s^\prime_5$};
    \node[draw, circle] (node9) at (7,-1) {$s^\prime_6$};
    \node[draw, circle] (node10) at (8,0) {$\plusOperator$};
    \node[draw, circle] (node11) at (9,0) {$s^\prime_7$};
    % Text on top
    \node[above] at (node1.north) { \footnotesize$\iChartFunction$};
    \node[above] at (node2.north) { \footnotesize$\iChartFunction$};
    \node[above] at (node3.north) {};
    \node[above] at (node4.north) { \footnotesize$\iChartFunction$};
    \node[above] at (node5.north) { \footnotesize$\iChartFunction$};
    \node[above] at (node65.north) { \footnotesize$\iChartFunction$};
    \node[above] at (node8.north) { \footnotesize$\iChartFunction$};
    \node[above] at (node9.north) { \footnotesize$\iChartFunction$};
    \node[above] at (node11.north) { \footnotesize$\iChartFunction$};
    % Connection
    \draw[->] (node1) -- (node2);
    \draw[->] (node2) -- (node3);
    \draw[->] (node3) -- (node4);
    \draw[->] (node3) -- (node5);
    \draw[->] (node5) -- (node6);
    \draw[->] (node4) -- (node6);
    \draw[->] (node6) -- (node65);
    \draw[->] (node65) -- (node7);
    \draw[->] (node7) -- (node8);
    \draw[->] (node7) -- (node9);
    \draw[->] (node8) -- (node10);
    \draw[->] (node9) -- (node10);
    \draw[->] (node10) -- (node11);
  \end{tikzpicture}
  \caption{Service composition instance}
  \label{fig:service_composition_instance}
\end{figure}




% \textbf{Loop} ($\oslash$). It composes a service composition by iteratively executing the same composition. $\oslash wsi$ mimics a composition where the service $wsi$ is executed a given number of times. In the following, $\oslash$ is considered as a sequence of $\oslash$ services with the same composition $wsi$.

% \textbf{Containment} ($\tau$). It composes two service, $wsi$ and $wsj$, in a containment relation. $wsi\tau wsj$ mimics a basic composition pattern where $wsj$ is called within $wsi$, meaning that $wsi$ assumes the role of a container and $wsj$ uses container-level functionalities (e.g., signature, encryption) to secure the message exchange. We note that the containment operator does not have a direct mapping to BPEL constructs because it is applied to a specific service before the BPEL process is even considered.
\subsection{Instance}
When the template is filled with the necessary services, it becomes an instance that reflects the actual implementation of those services.
This instance follows the same flow as the template, but but both \myLambda and \myGamma are replaced respectively by \iChartFunction~ which represent the transformation operations carried out by the service.

Let \G(\V,\E,\myLambda,\myGamma) be a Service Template, a Service Instance \G'(\V',\E,$\iChartFunction$) is a directed acyclic graph where:
$s_r=s'_r$, for each vertex \vi{}$\in$\V$_{\timesOperator}$$\cup$\V$_{\plusOperator}$ it exists a corresponding vertex \vi{}'$\in$\V'$_{\timesOperator}$$\cup$\V'$_{\plusOperator}$,
    and for each \vi{i}$\in$ \V\ it exists a corresponding \vi'{i}$\in$ \V'\ instantiated with a real service \vi{i} having a policy \Pset{i}, such that the following conditions hold:
    \begin{itemize}
      \item $s_i$ satisfies functional requirements in $G(V,E,\iChartFunction)$.
      \item \Pset{i} satisfies $\iChartFunction(v_i)$.
    \end{itemize}

    The Service  Instance  is generated by traversing the Service Template with a breadth-first search algorithm,
    starting from the root vertex \vi{r}. Then for each vertex \vi{i} in the Service Template, the corresponding vertex \vi{i}'$\in$ \V'\ is generated.
    Finally for each vertex  \vi{i}'$\in$ \V'\ a two step selection approach is applied as follows.
\begin{itemize}
  \item \textit{Selection Algorithm} - It matches requirements in $\iChartFunction$ with the policy $\iChartFunction$, and returns a set of services $S_i$ that satisfy the requirements.
  \item \textit{Comparison Algorithm} - Upon retrieving a set of compatible services, it produces a ranking of these services according their scoring function.
        The scoring function is calculated according some metrics, which evaluate the quality of the data resulting from the service execution.
        More details about the metrics are provided in Section \ref{sec:metrics}.
\end{itemize}




% \begin{figure}[H]
%   \centering

%   \begin{tikzpicture}
%     % Nodes
%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node11) at (0,1.2) {Sx};
%     \node[draw, circle, minimum size=1cm] (node1) at (0,0) {S1};
%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node10) at (0,-1.2) {Sy};

%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node22) at (2,1.2) {Sx};
%     \node[draw, circle, minimum size=1cm] (node2) at (2,0) {S2};
%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node21) at (2,-1.2) {Sy};

%     \node[draw, circle, minimum size=1cm] (node3) at (4,0) {$\timesOperator$};

%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node42) at (5,-1.5) {Sx};
%     \node[draw, circle, minimum size=1cm] (node4) at (6,-1.5) {S3};
%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node41) at (7,-1.5) {Sy};

%     \node[draw, circle, minimum size=1cm] (node5) at (6,1.5) {S4};
%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node51) at (5,1.5) {Sx};
%     \node[draw, circle, minimum size=0.4cm, draw=gray, text opacity=0.5] (node52) at (7,1.5) {Sy};
%     % Connection
%     \draw[->] (node1) -- (node2);
%     \draw[->] (node2) -- (node3);
%     \draw[->] (node3) -- (node4);
%     \draw[->] (node3) -- (node5);
%   \end{tikzpicture}
%   \caption{Service composition instance}
%   \label{fig:service_composition_instance}
% \end{figure}
% \[ \forall S \in \mathrm{S}_{C}  \exists  \iChartFunction(S) = \mathrm{S}_{1} \]


\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{serviceDetail.pdf}
  \caption{Service Detail}
  \label{fig:service_detail}reinstall remote-ssh
\end{figure}
